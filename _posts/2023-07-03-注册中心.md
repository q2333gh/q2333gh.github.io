---
layout: home
title:  "Registery Center"
categories: [Distributed System]
---
  
  

## 注册中心的Take Home Message

  

消费者视角：

输入：需求服务名字，注册中心的地址

输出：特定服务名称地址列表

这里放权给jvm内部自行选择负载均衡算法

  

生产者视角：

输入：每三十秒向注册中心汇报地址，和提供的服务名称

输出：注册中心回应收到了？

  

### 其他功能：

_水平扩展注册中心，不让注册中心成为整个业务的短板，瓶颈，带宽要够。精准扩展量实现需要profiler？ quantative approach？

_注册中心主动查询生产者状态

_注册中心一旦发现有生产者宕机，立即通知所有消费者，（对比30秒一次汇报）

_注册中心来做负载均衡？

_生产者分级。实例：以前是1对10。当1对1000的时候，就需要再加一个中间层，常见的如实例遍布全球，就需要加一层地区分层

为什么要实例遍布全球统一管理？方便一键CI和CD

_服务器集群有测试用和开发用，也可以基于此分层

  
  
  
  

负载均衡算法：

随机

轮询

权重

优先队列？maybe

  

### 其他优化点：

生产者和消费者在初始化的时候，应该取只在一个地方注册中心的ip和端口号，只在一个地方硬编码才遵循DRY原则

同时注册中心自身可以再度封装输入参数。符合最低信息熵。

  

负载均衡是放到注册中心处理好，还是全权给每个jvm服务器列表自己处理好？

  

### 其他重要概念：

springcloud设计了注册中心的接口

实现目前有Eureka和nacos

  

### 配置中心：
每个jvm启动以前都先问询注册中心来补全自己的配置，以及自身的自定义配置，由注册中心告知,  
  这其中有个问题:当注册中心不在线的情况,可以单体启动吗?

配置量上去以后，需要统一管理yaml文件的部分设置，

但是，第一次注册，即bootstrap.yaml总是需要重复输入一次，这在信息熵理论上是必要的吗？

  

多环境共享，即dev prod test 公共配置抽取为base.yaml遵循DRY