---
layout: home
title:  "java notes"
categories: [java]
# pinned: true
---


**Java**

优质参考书籍,不需要逐字阅读即选取对概念理解和工程优化用得到的地方,阅读,摘抄,并总结为THM
=======================================================================================

核心卷1,2 {#核心卷12 .list-paragraph}
---------

深入理解JVM {#深入理解jvm .list-paragraph}
-----------

java编程思想 {#java编程思想 .list-paragraph}
------------

java重要概念
============

从代码到程序运行的编译流程:字节码,虚拟机, {#从代码到程序运行的编译流程字节码虚拟机 .list-paragraph}
-----------------------------------------

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image1.png){width="1.968503937007874in"
> height="2.7753958880139984in"}

-   JIT编译器

> • 将热点代码保存为机器码

-   AOT预编译(JDK9)

> • 将字节码全部保存为机器码

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image2.png){width="1.968503937007874in"
> height="3.7143799212598427in"}

面向对象 {#面向对象 .list-paragraph}
--------

### 与C++面向对象的异同

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image3.png){width="1.968503937007874in"
> height="0.7761986001749781in"}

### 封装

-   封装

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image4.png){width="1.968503937007874in"
> height="0.640728346456693in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image5.png){width="1.968503937007874in"
> height="1.1952898075240594in"}
>
> •
> 构造函数,构造方法和普通方法的区别，只有权限修饰和方法名（和类名相同），虽然没有返回值，但是它没有返回类型，包括void!!
>
> ![desc](/assets/imgs/java/media/template_document.xml_image6.png){width="1.968503937007874in"
> height="0.5108737970253718in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image7.png){width="1.968503937007874in"
> height="1.1889632545931759in"}

-   访问修饰符//todo

> • 类内部属性全部私有,访问只能通过public 的getter 和setter方法

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image8.png){width="1.968503937007874in"
> height="0.6310323709536309in"}
>
> • 面向过程思维简单直接,但是缺少复用

-   类生成对象

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image9.png){width="1.968503937007874in"
> height="0.4417279090113736in"}

-   内部类//todo

> • 重要程度如何,在什么工程中必用吗?

-   什么是句柄?最简单的理解:句柄即this 指针

> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image10.png){width="1.968503937007874in"
> height="1.145559930008749in"}

### 继承

-   继承

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image11.png){width="1.968503937007874in"
> height="0.5442541557305337in"}
>
> • 抽象类
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image12.png){width="1.968503937007874in"
> height="0.42678149606299215in"}
>
> • 接口
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image13.png){width="1.968503937007874in"
> height="0.5757152230971129in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image14.png){width="1.968503937007874in"
> height="1.0505358705161856in"}
>
> • 抽象类和接口的异同
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image15.png){width="1.968503937007874in"
> height="1.2721106736657917in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image16.png){width="1.968503937007874in"
> height="0.11665244969378828in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image17.png){width="1.968503937007874in"
> height="0.4182250656167979in"}
>
> • 子类 继承 父类
>
> • 构造方法//todo
>
> • 父类没有无参构造时:
>
> • 定义
>
> ![desc](/assets/imgs/java/media/template_document.xml_image18.png){width="1.968503937007874in"
> height="1.4075317147856519in"}
>
> •
> 子类构造方法在调用时必须先调用父类的，由于父类没有无参构造，必须在子类中显式调用，修改子类构造方法如下即可：
>
> ![desc](/assets/imgs/java/media/template_document.xml_image19.png){width="1.968503937007874in"
> height="0.6539435695538057in"}

### 多态

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image20.png){width="1.968503937007874in"
> height="0.9593099300087489in"}
>
> • 接口
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image21.png){width="1.968503937007874in"
> height="0.3815354330708661in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image22.png){width="1.968503937007874in"
> height="0.46809383202099736in"}
>
> • 接口和抽象类的关系区别
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image23.jpeg){width="1.968503937007874in"
> height="3.1474234470691163in"}
>
> •
> java8接口自带适配器了,不用重写接口的所有方法,只需要写需要重写的部分方法
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image24.png){width="1.968503937007874in"
> height="0.6089851268591426in"}
>
> • Generics范型
>
> • Parameterized Type
>
> ![desc](/assets/imgs/java/media/template_document.xml_image25.png){width="1.968503937007874in"
> height="1.1657742782152232in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image26.png){width="1.968503937007874in"
> height="0.9198611111111111in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image27.png){width="1.968503937007874in"
> height="0.5106758530183727in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image28.png){width="1.968503937007874in"
> height="0.5291196412948381in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image29.png){width="1.968503937007874in"
> height="0.8735968941382327in"}
>
> • 范型方法
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image30.png){width="1.968503937007874in"
> height="0.9147320647419073in"}
>
> • 可变长参数
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image31.png){width="1.968503937007874in"
> height="1.4883814523184602in"}

反射 {#反射 .list-paragraph}
----

### 概念

-   图

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image32.png){width="1.968503937007874in"
> height="1.5331922572178478in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image33.png){width="1.968503937007874in"
> height="0.6615201224846894in"}

-   运行时,基本调用:

> • 1.创建Class类调用反射
>
> • 图
>
> • 重要应用:forName就可以读取其他的文本文件在运行动态生成不同对象
>
> ![desc](/assets/imgs/java/media/template_document.xml_image34.png){width="1.968503937007874in"
> height="2.504850174978128in"}
>
> • 2.获取一个类的实例对象
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image35.png){width="1.968503937007874in"
> height="1.1963921697287838in"}
>
> • 3.获取对象的基本信息
>
> • 对象名称
>
> • 对象属性
>
> • 对象方法
>
> • 获取构造器信息
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image36.png){width="1.968503937007874in"
> height="0.5021019247594051in"}
>
> • 获取方法
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image37.png){width="1.968503937007874in"
> height="1.187037401574803in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image38.png){width="1.968503937007874in"
> height="1.971790244969379in"}
>
> • 子主题 1
>
> • 调用方法
>
> • . . . 是可变长参数列表
>
> ![desc](/assets/imgs/java/media/template_document.xml_image39.png){width="1.968503937007874in"
> height="1.8790266841644794in"}

序列化//todo {#序列化todo .list-paragraph}
------------

### 概念

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image40.png){width="1.968503937007874in"
> height="0.6228357392825897in"}

-   用途

> • 传输

java syntax
===========

8种基本数据类型-4211 {#种基本数据类型-4211 .list-paragraph}
--------------------

### String不是基本数据类型.是一个String类

> ![desc](/assets/imgs/java/media/template_document.xml_image41.png){width="1.968503937007874in"
> height="3.3874070428696412in"}

-   char 16位 2字节 16进制:0000-ffff

> • 子主题 1

### 自动装箱和拆箱

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image42.png){width="1.968503937007874in"
> height="0.8705479002624672in"}

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image43.png){width="1.968503937007874in"
> height="1.1074890638670167in"}

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image44.png){width="1.968503937007874in"
> height="0.8884394138232721in"}

### 取整

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image45.png){width="1.968503937007874in"
> height="0.8944028871391076in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image46.png){width="1.968503937007874in"
> height="1.6000678040244969in"}
>
> • round
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image47.png){width="1.968503937007874in"
> height="0.7205468066491688in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image48.png){width="0.6299212598425197in"
> height="0.794248687664042in"}

-   向上取整 ceil向下取整 floor四舍五入取整 round

### 自动转型注意括号最高优先级和计算顺序从左到右转型

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image49.png){width="1.968503937007874in"
> height="0.27864720034995627in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image50.png){width="0.6299212598425197in"
> height="1.5686275153105862in"}

### 精度

-   小数

> ![desc](/assets/imgs/java/media/template_document.xml_image51.png){width="1.968503937007874in"
> height="0.39723206474190725in"}

### 转型

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image52.png){width="1.968503937007874in"
> height="1.1401979440069991in"}
>
> • 子主题 1

循环 {#循环 .list-paragraph}
----

### for循环的执行顺序

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image53.png){width="1.968503937007874in"
> height="0.5288517060367454in"}
>
> • 例题
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image54.png){width="1.968503937007874in"
> height="1.3415244969378828in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image55.png){width="1.968503937007874in"
> height="1.8170800524934383in"}
>
> • 实际使用
>
> ![desc](/assets/imgs/java/media/template_document.xml_image56.png){width="1.968503937007874in"
> height="1.3455599300087489in"}
>
> • int i=0 初始化只执行一次
>
> • i\<10 每次判断是否进入循环
>
> • i++,循环内部执行完成一次则执行一次i++
>
> • i++以后再次判断i\<10是否进入循环

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image57.png){width="1.968503937007874in"
> height="0.2894860017497813in"}

-   还可以break b;指定跳出多重循环,但是不建议使用了

理解:并行,并发,串行的概念 {#理解并行并发串行的概念 .list-paragraph}
-------------------------

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image58.png){width="1.968503937007874in"
> height="1.8761187664041994in"}

static关键字用法 {#static关键字用法 .list-paragraph}
----------------

### static对于类的属性/field

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image59.png){width="1.968503937007874in"
> height="0.5890015310586176in"}

### 存在JVM的Heap中

> ![desc](/assets/imgs/java/media/template_document.xml_image60.png){width="1.968503937007874in"
> height="1.2480719597550307in"}

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image61.png){width="1.968503937007874in"
> height="1.8730610236220473in"}

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image62.png){width="1.968503937007874in"
> height="1.226923665791776in"}

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image63.png){width="1.968503937007874in"
> height="1.548885608048994in"}

-   什么是内部类?

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image64.png){width="1.968503937007874in"
> height="0.24426727909011373in"}

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image65.png){width="1.968503937007874in"
> height="0.18050306211723535in"}

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image66.png){width="1.968503937007874in"
> height="1.11708552055993in"}

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image67.png){width="1.968503937007874in"
> height="1.3862707786526685in"}

invoke/Reflection反射 {#invokereflection反射 .list-paragraph}
---------------------

### introspectionmirror像是一个类照镜子,看自己的数据结构是什么样子的,报告自己的数据结构,和构造器,内部函数等.

### concept 概念

> ![desc](/assets/imgs/java/media/template_document.xml_image68.png){width="1.968503937007874in"
> height="0.4295909886264217in"}

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image69.png){width="1.968503937007874in"
> height="0.2315890201224847in"}

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image70.png){width="1.968503937007874in"
> height="0.6610870516185476in"}

-   在程序的运行过程中，对于任何一个类，都能够知道它的所有属性和方法；对于任意一个对象，都能够知道它的任意属性和方法，这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。

-   运行时获取到Introspection类或者对象(class Book/Book
    > book1)的属性和方法以后

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image71.png){width="1.968503937007874in"
> height="0.8231025809273841in"}
>
> • Introspection与Reflection

### 使用

-   原始new

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image72.jpg){width="1.968503937007874in"
> height="0.8332786526684165in"}

-   反射

> • 反射类
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image73.png){width="1.968503937007874in"
> height="0.5730621172353456in"}
>
> • 获取类Class
>
> • 获取类的的方法Method
>
> • 获取构造方法Constructor
>
> • 获取类的属性Field
>
> • 获取class对象的方式的主要三种：
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image74.png){width="1.968503937007874in"
> height="1.4401924759405074in"}
>
> • 根据类名：类名.class
>
> • myBook.classs
>
> • 根据对象：对象.getClass()
>
> • book1.getClass()
>
> • 根据全限定类名：Class.forName(全限定类名)
>
> • Class.forName(\"demo1.User\")
>
> • 获取到class对象以后实例化
>
> • newInstance
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image75.png){width="1.968503937007874in"
> height="0.3515190288713911in"}
>
> • 实例化方式有3种
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image76.png){width="1.968503937007874in"
> height="0.7913254593175854in"}
>
> • 实例
>
> ![desc](/assets/imgs/java/media/template_document.xml_image77.png){width="1.968503937007874in"
> height="0.6230413385826772in"}
>
> • 实例2
>
> ![desc](/assets/imgs/java/media/template_document.xml_image78.png){width="1.968503937007874in"
> height="1.9567169728783902in"}

### annotation注解 //todo

-   concept 概念

常量 {#常量 .list-paragraph}
----

### enum可以是常量的集合

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image79.png){width="1.968503937007874in"
> height="0.5236275153105862in"}

final {#final .list-paragraph}
-----

### THM

> ![desc](/assets/imgs/java/media/template_document.xml_image80.png){width="1.968503937007874in"
> height="1.0208486439195101in"}

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image81.png){width="1.968503937007874in"
> height="0.9606572615923009in"}

### THM

> ![desc](/assets/imgs/java/media/template_document.xml_image82.png){width="1.968503937007874in"
> height="0.9146205161854768in"}

-   final A-\>B

> • -\>
> 这个指向行为不能改变.B的值可以改变即指针存放的地址初始化之后便不能改变

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image83.png){width="1.968503937007874in"
> height="0.680097331583552in"}

Object类 {#object类 .list-paragraph}
--------

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image84.png){width="1.968503937007874in"
> height="1.8334962817147857in"}

-   equals实现

> • ==比较的是两个对象的引用值
>
> ![desc](/assets/imgs/java/media/template_document.xml_image85.png){width="1.968503937007874in"
> height="1.9533617672790902in"}
>
> • equals对比====
> 指针对比equals可以自行重载,如自定义了一个User的equals对比内部数据结构name,age是否相等
>
> ![desc](/assets/imgs/java/media/template_document.xml_image86.png){width="0.23622047244094488in"
> height="0.23622047244094488in"}
>
> • 面试常考重点!引用类型的==对比两个对象的指针存的地址值是否相等!
>
> ![desc](/assets/imgs/java/media/template_document.xml_image87.png){width="1.968503937007874in"
> height="0.7788429571303587in"}
>
> • Integer(1) 都存在常量池共用一个值
>
> • x地址可能是0x00
>
> • y地址可能是0x04
>
> • 因此引用x,y对象的地址不一样,但是指向是一样的

-   native关键词

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image88.png){width="1.968503937007874in"
> height="0.49753390201224845in"}
>
> • 使用原因
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image89.png){width="1.968503937007874in"
> height="0.47374781277340333in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image90.png){width="1.968503937007874in"
> height="1.1868919510061242in"}

-   toString实现

> • getClass反射获取对象,再获取反射对象的名称
>
> ![desc](/assets/imgs/java/media/template_document.xml_image91.png){width="1.968503937007874in"
> height="0.2287062554680665in"}

this {#this .list-paragraph}
----

### 概念

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image92.png){width="1.968503937007874in"
> height="0.41236220472440943in"}

super {#super .list-paragraph}
-----

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image93.png){width="1.968503937007874in"
> height="3.1486384514435697in"}

-   super(x,y) 向父类传参

异常 {#异常 .list-paragraph}
----

### 概念

-   如果try执行失败,则将程序运行跳转到catch部分的exception类接管,由异常类处理捕获到的异常,然后交回控制权给原来程序,finally是无论try成功与否都要执行

> ![desc](/assets/imgs/java/media/template_document.xml_image94.png){width="1.968503937007874in"
> height="0.8022583114610674in"}

### 分类

-   图

> • THM
>
> ![desc](/assets/imgs/java/media/template_document.xml_image95.png){width="1.968503937007874in"
> height="1.2573862642169729in"}

-   Error: java程序无法处理

> • 一般情况下jvm直接线程终止

-   exception

> • io异常
>
> • runtime异常
>
> • 用户自定义异常

### 处理机制

-   可以选择捕获或者抛出异常

-   图

> • try:监控区
>
> ![desc](/assets/imgs/java/media/template_document.xml_image96.png){width="1.968503937007874in"
> height="0.7435301837270342in"}
>
> • THM
>
> ![desc](/assets/imgs/java/media/template_document.xml_image97.jpg){width="1.968503937007874in"
> height="1.545945975503062in"}

编解码 {#编解码 .list-paragraph}
------

### 要点1

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image98.png){width="1.968503937007874in"
> height="0.38575240594925636in"}

FP 函数式编程another new world {#fp-函数式编程another-new-world .list-paragraph}
------------------------------

![desc](/assets/imgs/java/media/template_document.xml_image99.png){width="0.23622047244094488in"
height="0.23622047244094488in"}

### 为什么需要函数式编程?

-   子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image100.png){width="1.968503937007874in"
> height="1.1789971566054243in"}

### 概念

-   子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image101.png){width="1.968503937007874in"
> height="1.4222200349956255in"}

HoF编程 {#hof编程 .list-paragraph}
-------

annotation注解 {#annotation注解 .list-paragraph}
--------------

### 基本使用

-   \@Data 提供了功能可以理解,但是如何实现的?

### 注解原理? todo

java内部:(对象,工具)的选择
==========================

THM 只用String 和StringBuffer. 不用StringBuilder {#thm-只用string-和stringbuffer.-不用stringbuilder .list-paragraph}
------------------------------------------------

> ![desc](/assets/imgs/java/media/template_document.xml_image102.png){width="1.968503937007874in"
> height="1.2101968503937008in"}

STL, Container 容器//todo
=========================

![desc](/assets/imgs/java/media/template_document.xml_image103.png){width="0.23622047244094488in"
height="0.23622047244094488in"}

容器分类 {#容器分类 .list-paragraph}
--------

### Collection

-   概览图以及原理解读

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image104.png){width="1.968503937007874in"
> height="1.039194006999125in"}
>
> • Set
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image105.png){width="1.968503937007874in"
> height="0.3214785651793526in"}
>
> • 红黑树,一种自动平衡的二叉树,高插入和查找性能
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image106.png){width="1.968503937007874in"
> height="0.9451946631671041in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image107.png){width="1.968503937007874in"
> height="1.1188899825021872in"}
>
> •
>
> • 子主题 4
>
> ![desc](/assets/imgs/java/media/template_document.xml_image108.png){width="1.968503937007874in"
> height="1.1879647856517934in"}
>
> • 子主题 5
>
> ![desc](/assets/imgs/java/media/template_document.xml_image109.png){width="1.968503937007874in"
> height="1.3382174103237094in"}
>
> • 旋转
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image110.png){width="1.968503937007874in"
> height="0.5056091426071742in"}
>
> • Queue也可以用ArrayDeque
>
> ![desc](/assets/imgs/java/media/template_document.xml_image111.png){width="1.968503937007874in"
> height="1.4894149168853894in"}

-   使用

> ![desc](/assets/imgs/java/media/template_document.xml_image112.png){width="0.23622047244094488in"
> height="0.23622047244094488in"}
>
> • ArrayList
>
> ![desc](/assets/imgs/java/media/template_document.xml_image113.png){width="0.23622047244094488in"
> height="0.23622047244094488in"}
>
> • 子主题 1
>
> •
>
> • 如何把id添加进 list数组集合中的Rowpos对象集合中的 指定第一个对象
> 的id属性中去??

### Map

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image114.png){width="1.968503937007874in"
> height="1.024562554680665in"}

-   什么是分段锁?Cool

> ![desc](/assets/imgs/java/media/template_document.xml_image115.png){width="1.968503937007874in"
> height="0.6016590113735784in"}

设计模式 {#设计模式 .list-paragraph}
--------

### 迭代器

### 不记得了就去看CS61B

多线程,并发问题,无锁对应OS的 Concurrency
========================================

基本使用 {#基本使用-1 .list-paragraph}
--------

### 两种启用多线程方法

-   继承Thread类使用

> • extends继承线程类
>
> ![desc](/assets/imgs/java/media/template_document.xml_image116.png){width="1.968503937007874in"
> height="0.8899748468941382in"}
>
> • start()启动线程
>
> ![desc](/assets/imgs/java/media/template_document.xml_image117.png){width="1.968503937007874in"
> height="0.7135192475940507in"}
>
> • java启动以后是一个java进程,main线程开启了 cat线程,内部名称Thread-0,
>
> • 重要:
>
> ![desc](/assets/imgs/java/media/template_document.xml_image118.png){width="1.968503937007874in"
> height="0.1371894138232721in"}
>
> • main线程和cat线程会交替执行
>
> ![desc](/assets/imgs/java/media/template_document.xml_image119.png){width="1.968503937007874in"
> height="1.1446073928258969in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image120.png){width="1.968503937007874in"
> height="1.7125371828521434in"}
>
> • 即各
> 线程独立如果main执行60s,cat执行80smain会自行停止,cat会执行到80s然后退出java进程
>
> • 关联理解后面的守护线程守护线程则不是独立的,是关联型的

-   更好的多线程实现:实现Runnable接口,再使用Thread类代理要执行的多线程对象静态代理

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image121.png){width="1.968503937007874in"
> height="1.1914632545931758in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image122.png){width="1.968503937007874in"
> height="0.8273425196850394in"}
>
> • 好处: 不必继承Thread全部方法,简洁,可以实现其他的必要继承
>
> • 用例
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image123.png){width="1.968503937007874in"
> height="0.7158191163604549in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image124.png){width="1.968503937007874in"
> height="0.5988429571303587in"}
>
> • 设计模式:静态代理你没有这个功能/我帮你实现这个功能
>
> • 简单demo
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image125.png){width="1.968503937007874in"
> height="0.772567804024497in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image126.png){width="1.968503937007874in"
> height="0.7287653105861768in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image127.png){width="1.968503937007874in"
> height="0.7064873140857393in"}

### 为什么是start0()?

-   不使用start时,run方法没完成不执行下面的main方法,串行化执行了,阻塞

> ![desc](/assets/imgs/java/media/template_document.xml_image128.png){width="1.968503937007874in"
> height="1.1602438757655293in"}

-   底层

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image129.png){width="1.968503937007874in"
> height="0.9036373578302712in"}
>
> • 不同OS执行多线程的内核实现不同.所以调用底层方法 syscall fork() and
> exec()
>
> ![desc](/assets/imgs/java/media/template_document.xml_image130.png){width="1.968503937007874in"
> height="0.842746062992126in"}

线程内的常用方法 {#线程内的常用方法 .list-paragraph}
----------------

### 设置和获取线程名

-   setName()

-   getName()

### 控制线程运行状态

-   运行

> • start()

-   中断

> • interrupt()
>
> • 图
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image131.png){width="1.968503937007874in"
> height="0.5197922134733158in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image132.png){width="1.968503937007874in"
> height="0.9519466316710411in"}
>
> • 提前结束休眠继续执行while循环
>
> ![desc](/assets/imgs/java/media/template_document.xml_image133.png){width="1.968503937007874in"
> height="0.768908573928259in"}

-   休眠

> • sleep()
>
> • 设置线程为TimeWaiting状态

-   关闭

> • 多种方法
>
> • 如t.close();

### 设置线程优先级

-   getPriority

-   setPriority

-   注意:

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image134.png){width="1.968503937007874in"
> height="0.32808398950131235in"}

### \<线程内\>共享数据

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image135.png){width="1.968503937007874in"
> height="0.44625984251968503in"}

线程间的切换 {#线程间的切换 .list-paragraph}
------------

### 让步

-   yield

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image136.png){width="1.968503937007874in"
> height="0.22560367454068242in"}
>
> •
> yied让步视情况执行,如果资源很多则java自动不予让步资源紧张则yield让步实现
>
> • 线程保持Runnable状态

### 插队

-   join

> •
> join以后必须执行完毕插队线程内的所有任务,其他线程全部被设置为线程waiting状态,才执行其他线程
>
> • 例子
>
> • 123ABC45
>
> • 例子
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image137.png){width="1.968503937007874in"
> height="0.4349015748031496in"}
>
> • t2.join() 则让t2插队
>
> ![desc](/assets/imgs/java/media/template_document.xml_image138.png){width="1.968503937007874in"
> height="0.8455774278215223in"}

### 守护线程

-   启用方法

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image139.png){width="1.968503937007874in"
> height="0.5052624671916011in"}

-   守护线程的运行依附用户线程

> • 用户线程关闭时会自动调用守护线程关闭
>
> • 用户线程:即用户创建的所有线程

-   守护线程重要应用:GC

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image140.png){width="1.968503937007874in"
> height="0.21950896762904637in"}

线程生命周期 {#线程生命周期 .list-paragraph}
------------

### 图

-   6种或者7种状态

> ![desc](/assets/imgs/java/media/template_document.xml_image141.png){width="1.968503937007874in"
> height="1.3260061242344707in"}
>
> • 调度器: scheduler with in some polocies and algorithm
>
> ![desc](/assets/imgs/java/media/template_document.xml_image142.png){width="1.968503937007874in"
> height="1.2947080052493438in"}
>
> • 挂起suspend()建议不要使用/deprecated

### threadA.getState()方法

-   图

> • 以及 waiting timeWaiting block terminated
>
> ![desc](/assets/imgs/java/media/template_document.xml_image143.png){width="1.7421259842519685in"
> height="1.8208661417322836in"}

-   返回

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image144.png){width="1.968503937007874in"
> height="1.0213298337707786in"}

线程间的通信 同步机制对比OS的 进程间通信理解 {#线程间的通信-同步机制对比os的-进程间通信理解 .list-paragraph}
--------------------------------------------

### 概念

-   图

> • 即内存读写
>
> ![desc](/assets/imgs/java/media/template_document.xml_image145.png){width="1.968503937007874in"
> height="0.4586800087489064in"}

### 使用

-   sychronized即互斥锁

> • 简单使用
>
> • 图
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image146.png){width="1.968503937007874in"
> height="1.0695538057742782in"}
>
> • 红框二选一使用
>
> ![desc](/assets/imgs/java/media/template_document.xml_image147.png){width="1.968503937007874in"
> height="1.6144258530183726in"}
>
> • 锁
>
> • 加锁
>
> • 静态方法时:
>
> • 二选一
>
> ![desc](/assets/imgs/java/media/template_document.xml_image148.png){width="1.968503937007874in"
> height="0.7279647856517936in"}
>
> • 加锁位置
>
> ![desc](/assets/imgs/java/media/template_document.xml_image149.png){width="0.23622047244094488in"
> height="0.23622047244094488in"}
>
> • todo
>
> • 互斥锁,即锁的全称?
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image150.png){width="1.968503937007874in"
> height="0.3686045494313211in"}
>
> • 释放锁结合运行⑦态图理解
>
> • 图
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image151.png){width="1.968503937007874in"
> height="0.9393383639545057in"}
>
> • 图
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image152.png){width="1.968503937007874in"
> height="0.8622845581802274in"}
>
> • 优化:优先使用同步代码块,锁范围更小,性能可能更高
>
> • 局限
>
> • 图
>
> • 最好直接使用concurrent包
>
> ![desc](/assets/imgs/java/media/template_document.xml_image153.png){width="1.968503937007874in"
> height="0.870252624671916in"}
>
> • 注意
>
> • sleep()方法
>
> ![desc](/assets/imgs/java/media/template_document.xml_image154.png){width="1.968503937007874in"
> height="0.837179571303587in"}

-   new ReentrantLock()更精细控制的锁

> • 对比
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image155.png){width="1.968503937007874in"
> height="1.5218252405949257in"}

### 思考

-   能否在临界点才执行同步机制?如1w张票64线程并发获取.在最后1000张才对票仓类加同步锁这样是否可以提高并发性能?

> • 解法1
>
> • 对象锁
>
> • 1w张票
> 9000张无锁剩下1000张票对ticket对象加上synchronized关键词,调用反射方法?运行时动态生成?
>
> • 分段锁?

IO//todo对应OS中的 Persistence
==============================

文件 {#文件 .list-paragraph}
----

### 创建文件

-   

> ![desc](/assets/imgs/java/media/template_document.xml_image156.png){width="1.968503937007874in"
> height="0.9681167979002625in"}
>
> • 1
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image157.png){width="1.968503937007874in"
> height="0.3195844269466317in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image158.png){width="1.968503937007874in"
> height="1.0797703412073492in"}
>
> • 2
>
> • 图
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image159.png){width="1.968503937007874in"
> height="1.7125984251968505in"}
>
> • 3

### 读取文件信息如inode 的数据结构

-   用例

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image160.png){width="1.968503937007874in"
> height="0.8940616797900263in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image161.png){width="1.9586614173228347in"
> height="2.106299212598425in"}

-   子主题 2

目录 {#目录 .list-paragraph}
----

### 创建目录

-   用例

> • 图
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image162.png){width="1.968503937007874in"
> height="1.0454735345581803in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image163.png){width="1.8700787401574803in"
> height="0.9251968503937008in"}

### 删除目录

-   F.delete();

### 查询目录是否存在

-   F.exists();

### 修改目录

IO流用的不是特别多, 同级别IO操作不少事基于DB-SQL层的DB即是一个高级的FileSystem {#io流用的不是特别多-同级别io操作不少事基于db-sql层的db即是一个高级的filesystem .list-paragraph}
------------------------------------------------------------------------------

### In , Out 是相对于JVM 与 IO 的关系

> ![desc](/assets/imgs/java/media/template_document.xml_image164.png){width="1.968503937007874in"
> height="1.2464654418197725in"}

### 字节:如图片,视频,可执行文件

-   InputStream

> • 方法:
>
> • .read()
>
> •
> 读取获得到的IO流,读取方式:添加while循环持续读取,文件末尾会读取到-1,read内部存在一个索引index指示器表示读取到字节流的指定位置了
>
> • 单字节
>
> • 指定多字节
>
> •
> 从指定字节内偏移量读取指定长度字节偏移量尝尝关联前面的index应用在读取图片如105kb图片一次读取100kb,则最后一次读取为read(image,0,len)
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image165.png){width="1.968503937007874in"
> height="1.1244816272965878in"}
>
> • read()返回值为读取到的字节长度 , 如此处设置为1024
>
> ![desc](/assets/imgs/java/media/template_document.xml_image166.png){width="1.968503937007874in"
> height="0.7897134733158355in"}

-   OutputStream

> • 方法
>
> • .write()
>
> • 子主题 1
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image167.png){width="1.968503937007874in"
> height="0.4126334208223972in"}

-   复制

> • 图
>
> • 也许4kb 是个不错的buf值?
>
> ![desc](/assets/imgs/java/media/template_document.xml_image168.png){width="1.968503937007874in"
> height="0.8754877515310586in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image169.png){width="1.968503937007874in"
> height="0.736172353455818in"}

### 字符内部Unicode自动处理编码

-   结构

> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image170.png){width="1.968503937007874in"
> height="1.968503937007874in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image171.png){width="1.968503937007874in"
> height="1.3897998687664042in"}

-   字符输入

> • 子主题 1
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image172.png){width="1.968503937007874in"
> height="0.44819772528433943in"}
>
> • 子主题 2

-   字符输出

> • 子主题 1
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image173.png){width="1.968503937007874in"
> height="0.7363768591426072in"}

处理流/包装流 {#处理流包装流 .list-paragraph}
-------------

### 概念

-   设计模式:装饰器模式

> • 简单实现
>
> • 抽象父类
>
> • 子主题 1
>
> • 两个方法可以写为一个,多态自动重载
>
> ![desc](/assets/imgs/java/media/template_document.xml_image174.png){width="1.968503937007874in"
> height="0.3911220472440945in"}
>
> • 子类
>
> • 节点流
>
> • 字节读取
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image175.png){width="1.968503937007874in"
> height="0.44797462817147854in"}
>
> • 字符读取
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image176.png){width="1.968503937007874in"
> height="0.4463724846894138in"}
>
> • 包装类
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image177.png){width="1.968503937007874in"
> height="0.7577023184601924in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image178.png){width="1.968503937007874in"
> height="1.128523622047244in"}
>
> • 使用:
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image179.png){width="1.968503937007874in"
> height="0.31116141732283464in"}

-   产生原因

> • 将多个不同类型的节点流整合为一个包装流
>
> ![desc](/assets/imgs/java/media/template_document.xml_image180.png){width="1.968503937007874in"
> height="0.7398709536307961in"}
>
> •
>
> ![desc](/assets/imgs/java/media/template_document.xml_image181.png){width="1.968503937007874in"
> height="0.3216819772528434in"}

性能blocking IOnon-blocking IONIO / AIO需要OS 的 基本IO知识 作为前置 {#性能blocking-ionon-blocking-ionio-aio需要os-的-基本io知识-作为前置 .list-paragraph}
--------------------------------------------------------------------

### 子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image182.png){width="1.968503937007874in"
> height="0.9459383202099737in"}

-   why buffer?

> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image183.png){width="1.968503937007874in"
> height="0.8737062554680665in"}

### 后来的Linux 的 新的IO接口 使用了 Kernel-User 共用缓冲区, 更高效了

> ![desc](/assets/imgs/java/media/template_document.xml_image184.png){width="1.968503937007874in"
> height="1.4498895450568678in"}

### blocking IO

-   子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image185.png){width="1.968503937007874in"
> height="0.2702701224846894in"}

-   用户进程会一直等待,即进程进入waitting 状态

> ![desc](/assets/imgs/java/media/template_document.xml_image186.png){width="1.968503937007874in"
> height="1.3099409448818897in"}
>
> • ready 和running 可以归为 一类状态
>
> ![desc](/assets/imgs/java/media/template_document.xml_image187.png){width="1.968503937007874in"
> height="0.691729002624672in"}

-   单个线程sleep 百分比太多. 而且线程越来越多.
    > 线程上下文切换越来越频繁,内存占用越来越多

> ![desc](/assets/imgs/java/media/template_document.xml_image188.png){width="1.968503937007874in"
> height="0.5526421697287839in"}

### non-blocking IO

-   这立马带来一个问题:
    > 线程完全不知道合适可以获取到请求的资源,就已经再做后面的操作了.
    > 需要从程序员角度编写异步代码,提前告知OS. 我待会儿要用到xxx资源.
    > Kernel 缓冲区现在没有线程要得资源,告知没有线程反复请求,
    > 造成了大量的Kernel mode 和User mode 的切换编程思路产生了改变

> ![desc](/assets/imgs/java/media/template_document.xml_image189.png){width="1.968503937007874in"
> height="0.587412510936133in"}

-   子主题 2

> ![desc](/assets/imgs/java/media/template_document.xml_image190.png){width="1.968503937007874in"
> height="1.8003827646544182in"}
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image191.png){width="1.968503937007874in"
> height="1.00459864391951in"}
>
> • 应用场景有哪些??
>
> • 子主题 1

### IO Multiplexing//todo

-   是否有些像线程池? 不过现在是IO池??

> ![desc](/assets/imgs/java/media/template_document.xml_image192.png){width="1.968503937007874in"
> height="0.12261373578302712in"}
>
> • 子主题 1
>
> ![desc](/assets/imgs/java/media/template_document.xml_image193.png){width="1.968503937007874in"
> height="0.9091940069991251in"}
>
> • 子主题 2
>
> ![desc](/assets/imgs/java/media/template_document.xml_image194.png){width="1.968503937007874in"
> height="1.339374453193351in"}
>
> • 子主题 3
>
> ![desc](/assets/imgs/java/media/template_document.xml_image195.png){width="1.968503937007874in"
> height="1.4869389763779528in"}
>
> • 子主题 4
>
> ![desc](/assets/imgs/java/media/template_document.xml_image196.png){width="1.968503937007874in"
> height="0.7599004811898513in"}

### Asynconous IO

-   子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image197.png){width="1.968503937007874in"
> height="0.3742147856517935in"}
>
> •
> 即告诉内核要一个IO操作,然后这个进程就去做其他不需要这个IO操作的其他事情,kernel会通知和送达IO数据回来此时可以发现\*\*进程没有waitting状态.
> 仍然是ready或者running状态\*\*
>
> ![desc](/assets/imgs/java/media/template_document.xml_image198.png){width="1.968503937007874in"
> height="0.4734372265966754in"}
>
> • 子主题 2
>
> ![desc](/assets/imgs/java/media/template_document.xml_image199.png){width="1.968503937007874in"
> height="1.3188582677165355in"}
>
> • 现在2023 Linux都 6,x 了. 已经有成熟的AIO模型
>
> ![desc](/assets/imgs/java/media/template_document.xml_image200.png){width="1.968503937007874in"
> height="1.6583672353455818in"}

### 子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image201.png){width="1.968503937007874in"
> height="0.3632764654418198in"}

### 子主题 7

> ![desc](/assets/imgs/java/media/template_document.xml_image202.png){width="1.968503937007874in"
> height="0.420501968503937in"}

### Linux AIO history

-   子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image203.png){width="1.968503937007874in"
> height="0.28050524934383203in"}

-   子主题 2

> ![desc](/assets/imgs/java/media/template_document.xml_image204.png){width="1.968503937007874in"
> height="0.4205774278215223in"}

-   shared mem 看起来挺牛的.少了一次内存复制过程,这其中有安全要考虑

> ![desc](/assets/imgs/java/media/template_document.xml_image205.png){width="1.968503937007874in"
> height="0.8060793963254593in"}

### Java New IO

-   子主题 1

网络编程Network Programming需要先理解IO的基本概念和实现
=======================================================

Socket套接字 {#socket套接字 .list-paragraph}
------------

### 子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image206.png){width="1.968503937007874in"
> height="1.7396084864391952in"}

子主题 2 {#子主题-2 .list-paragraph}
--------

### 子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image207.png){width="1.968503937007874in"
> height="1.14290791776028in"}

JVMconcepts highly derive from OS
=================================

main {#main .list-paragraph}
----

### 子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image208.png){width="1.968503937007874in"
> height="2.7807119422572177in"}

-   子主题 1

指令 {#指令 .list-paragraph}
----

### 子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image209.png){width="1.968503937007874in"
> height="0.8629702537182852in"}

-   子主题 1

> ![desc](/assets/imgs/java/media/template_document.xml_image210.png){width="1.968503937007874in"
> height="0.6634186351706036in"}

子主题 3 {#子主题-3 .list-paragraph}
--------

JAVA版本重要特性,演化,
======================

简单发展历史 {#简单发展历史 .list-paragraph}
------------

### 

> ![desc](/assets/imgs/java/media/template_document.xml_image211.png){width="1.968503937007874in"
> height="0.8555424321959755in"}

Take Home Message
=================
